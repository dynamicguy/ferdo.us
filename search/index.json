[{"content":"Scaling and Normalizing Arrays: A Practical Guide for Data Preprocessing In machine learning, data analysis, and scientific computing, raw data often comes in different scales. One feature might range from 0 to 1, while another spans 1,000 to 100,000. Feeding such mismatched data into algorithms can lead to poor performance, slow convergence, or biased results. This is where scaling and normalizing arrays come in—essential preprocessing steps that bring features to a common scale.\nIn this post, we’ll explore what scaling and normalization mean, the key techniques, when to use each, and how to implement them in Python using NumPy and scikit-learn.\nWhy Scale or Normalize? Most distance-based algorithms (like K-Means, KNN, SVM) and gradient-based methods (like neural networks, logistic regression) are sensitive to the magnitude of features. Without scaling:\nFeatures with larger ranges dominate the model. Training becomes unstable or slow. Interpretability of coefficients (e.g., in linear models) is compromised. Goal: Make features comparable without distorting differences in ranges of values.\nKey Techniques 1. Min-Max Scaling (Normalization to [0,1]) Transforms data to a fixed range, usually [0, 1].\n$$ X_{\\text{scaled}} = \\frac{X - X_{\\min}}{X_{\\max} - X_{\\min}} $$ When to use: When you need bounded values (e.g., neural networks with sigmoid/tanh activations, image pixel normalization). Pros: Preserves the original distribution shape; interpretable. Cons: Sensitive to outliers (one extreme value compresses all others). Python Example (NumPy) 1 2 3 4 5 6 7 8 9 import numpy as np def min_max_scale(arr): return (arr - arr.min()) / (arr.max() - arr.min()) X = np.array([1, 5, 10, 15, 20]) X_scaled = min_max_scale(X) print(X_scaled) # Output: [0. 0.21 0.47 0.74 1. ] With scikit-learn 1 2 3 4 5 6 from sklearn.preprocessing import MinMaxScaler scaler = MinMaxScaler() X = np.array([[1], [5], [10], [15], [20]]) X_scaled = scaler.fit_transform(X) print(X_scaled.flatten()) 2. Standardization (Z-score Normalization) Centers data around mean 0 with standard deviation 1.\n$$ X_{\\text{standardized}} = \\frac{X - \\mu}{\\sigma} $$ When to use: Most common choice. Ideal for algorithms assuming Gaussian distribution (e.g., linear regression, logistic regression, PCA). Pros: Robust to outliers; works well with gradient descent. Cons: Doesn’t bound values (can be negative or \u0026gt;1). Python Example 1 2 3 4 5 6 7 def standardize(arr): return (arr - arr.mean()) / arr.std() X = np.array([1, 5, 10, 15, 20]) X_std = standardize(X) print(X_std) # Output: [-1.42 -0.66 -0.08 0.66 1.42] With scikit-learn 1 2 3 4 5 from sklearn.preprocessing import StandardScaler scaler = StandardScaler() X_scaled = scaler.fit_transform(X.reshape(-1, 1)) print(X_scaled.flatten()) 3. Robust Scaling Uses median and interquartile range (IQR) instead of mean/std.\n$$ X_{\\text{robust}} = \\frac{X - \\text{median}}{IQR} $$ When to use: Data with outliers. Pros: Outlier-resistant. Cons: Less intuitive scaling. 1 2 3 4 from sklearn.preprocessing import RobustScaler scaler = RobustScaler() X_robust = scaler.fit_transform(X.reshape(-1, 1)) 4. Max Absolute Scaling Scales by dividing by the maximum absolute value.\n$$ X_{\\text{scaled}} = \\frac{X}{|X|_{\\max}} $$ Range: [-1, 1] Great for sparse data (e.g., text TF-IDF). 1 2 3 4 from sklearn.preprocessing import MaxAbsScaler scaler = MaxAbsScaler() X_scaled = scaler.fit_transform(X.reshape(-1, 1)) Comparison Table Method Range Outlier Robust? Use Case Min-Max [0,1] or custom No Neural nets, bounded inputs Standardization ~[-3,3] Moderate Most ML algorithms Robust Scaling Varies Yes Outlier-heavy data MaxAbs Scaling [-1,1] Yes Sparse data Best Practices Fit on Training Data Only\nNever use test data statistics to avoid data leakage.\n1 2 3 scaler = StandardScaler() X_train_scaled = scaler.fit_transform(X_train) X_test_scaled = scaler.transform(X_test) # Only transform! Apply Same Transformation to All Splits\nConsistency is key.\nInverse Transform When Needed\nConvert predictions back to original scale.\n1 X_original = scaler.inverse_transform(X_scaled) Handle 1D vs 2D Arrays\nscikit-learn expects 2D input (n_samples × n_features).\nReal-World Example: Scaling Before PCA 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 from sklearn.decomposition import PCA from sklearn.preprocessing import StandardScaler import numpy as np # Generate sample data np.random.seed(42) X = np.random.randn(100, 5) * [1, 10, 100, 1000, 0.1] + [0, 50, 500, 5000, 0] # Without scaling: high-variance features dominate pca_raw = PCA(n_components=2) X_pca_raw = pca_raw.fit_transform(X) # With scaling scaler = StandardScaler() X_scaled = scaler.fit_transform(X) pca = PCA(n_components=2) X_pca = pca.fit_transform(X_scaled) print(\u0026#34;Explained variance (scaled):\u0026#34;, pca.explained_variance_ratio_) Result: Scaling ensures all features contribute fairly to principal components.\nConclusion Scaling ≠ Normalization — though often used interchangeably:\nNormalization typically refers to rescaling to a norm (e.g., unit norm or [0,1]). Scaling is a broader term including standardization. Rule of Thumb:\nUse StandardScaler by default. Use MinMaxScaler when you need bounded values. Use RobustScaler if outliers are a concern. Proper scaling is a small step that leads to giant leaps in model performance.\nYour Turn: What’s your go-to scaler? Drop a comment or tweet @ferdous!\nHappy preprocessing!\n","date":"2025-11-16T00:00:00Z","image":"https://ferdo.us/p/scaling-normalizing-array/cover_hu_e59e1349f7e0c2ed.jpg","permalink":"https://ferdo.us/p/scaling-normalizing-array/","title":"Scaling and Normalizing Arrays - A Practical Guide for Data Preprocessing"},{"content":"Efficient State Management in React 19: A Practical Guide for Modern Developers Posted on November 22, 2025 by Ferdous · Dhaka, Bangladesh\nReact 19 is finally here, and with it comes a paradigm shift in how we think about state management. Gone are the days of juggling useState, useReducer, and third-party libraries for every complex app. React 19 introduces first-class, compiler-optimized state primitives that make your apps faster, smaller, and easier to reason about—without sacrificing flexibility.\nIn this post, we’ll explore:\nWhat’s new in React 19’s state system When to use useState vs. use vs. the new useActionState How the React Compiler eliminates unnecessary re-renders Best practices for 2025 and beyond Let’s dive in.\n1. The Big News: React Compiler + Smarter State React 19 ships with the React Compiler (formerly \u0026ldquo;React Forget\u0026rdquo;) enabled by default in supported build tools (Next.js 15+, Vite + React plugin, etc.). This means:\n1 2 const [count, setCount] = useState(0); // No memo, no useCallback needed — the compiler handles it No more manual memoization hell. The compiler automatically skips re-renders when props or state haven’t meaningfully changed.\nPro Tip: Use react-strict-mode in dev to catch accidental mutations. The compiler warns you.\n2. The New State Primitives useActionState – For Form + Async Logic Replace useState + useEffect + loading flags with one hook:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 function AddTodo() { const [state, action, pending] = useActionState(addTodo, { error: null, success: false }); return ( \u0026lt;form action={action}\u0026gt; \u0026lt;input name=\u0026#34;title\u0026#34; disabled={pending} /\u0026gt; \u0026lt;button disabled={pending}\u0026gt; {pending ? \u0026#39;Adding...\u0026#39; : \u0026#39;Add Todo\u0026#39;} \u0026lt;/button\u0026gt; {state.error \u0026amp;\u0026amp; \u0026lt;p style={{color: \u0026#39;red\u0026#39;}}\u0026gt;{state.error}\u0026lt;/p\u0026gt;} {state.success \u0026amp;\u0026amp; \u0026lt;p style={{color: \u0026#39;green\u0026#39;}}\u0026gt;Added!\u0026lt;/p\u0026gt;} \u0026lt;/form\u0026gt; ); } No try/catch, no setLoading(true), no race conditions. Just declarative async state.\nuse – The Promise \u0026amp; Context Superhook Read a promise anywhere in your component:\n1 2 3 4 function TodoList({ todoPromise }) { const todos = use(todoPromise); // Suspends automatically return todos.map(todo =\u0026gt; \u0026lt;TodoItem key={todo.id} todo={todo} /\u0026gt;); } No useEffect + useState dance. Works with any promise—including data from React.cache.\nThe Old Way (React 18) 1 2 3 4 5 6 7 8 9 10 11 const [search, setSearch] = useState(\u0026#39;\u0026#39;); const [status, setStatus] = useState(\u0026#39;all\u0026#39;); const [items, setItems] = useState([]); const [loading, setLoading] = useState(false); useEffect(() =\u0026gt; { const timer = setTimeout(() =\u0026gt; { fetchFiltered(search, status); }, 300); return () =\u0026gt; clearTimeout(timer); }, [search, status]); Boilerplate. Re-renders everywhere.\nThe React 19 Way 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026#39;use cache\u0026#39;; async function getItems(search: string, status: string) { const res = await fetch(`/api/items?search=${search}\u0026amp;status=${status}`); return res.json(); } function Dashboard() { const [search, setSearch] = useState(\u0026#39;\u0026#39;); const [status, setStatus] = useState(\u0026#39;all\u0026#39;); // Compiler knows: only re-run when search/status change const items = use(getItems(search, status)); const [formState, submit] = useActionState(createItem, { error: null, success: false }); return ( \u0026lt;\u0026gt; \u0026lt;SearchBar value={search} onChange={setSearch} /\u0026gt; \u0026lt;StatusFilter value={status} onChange={setStatus} /\u0026gt; \u0026lt;ItemList items={items} /\u0026gt; \u0026lt;AddItemForm action={submit} state={formState} /\u0026gt; \u0026lt;/\u0026gt; ); } Zero manual memoization. Zero loading spinners. Zero bugs.\n3. When to Use What (Decision Tree) Scenario Recommended Tool Local UI state (toggle, input) useState Form with async submit useActionState Data fetching use(promise) + cache Global state (user, theme) Context + use Complex app state Still use Zustand/XState — but now only for logic, not perf Rule of Thumb: If React Compiler can optimize it, don’t reach for Redux.\n4. Performance Tips for React 19 Enable the Compiler\n1 2 # next.config.js experimental: { reactCompiler: true } Mark Pure Functions\n1 2 \u0026#39;use cache\u0026#39;; function expensiveCalc(a, b) { ... } Avoid Mutating State\n1 2 3 4 // Don\u0026#39;t state.items.push(newItem); // Do return { ...state, items: [...state.items, newItem] }; Use Server Components for Data\nFetch in RSC → pass promise to client → use(promise).\nFinal Thoughts React 19 doesn’t just give you new hooks—it changes how you architect apps. State is now:\nDeclarative (not imperative) Optimized by default Integrated with the server You write less code, get faster apps, and spend more time building features.\nWhat’s Next? Migrate one component to useActionState Turn on React Compiler in your project Have a React 19 tip or war story? Drop it in the comments or tweet me @ferdous.\nLet’s make state management boring again—in the best way possible.\nHappy coding!\nFerdous\nDhaka, Bangladesh\nNovember 22, 2025\nP.S. Next week: \u0026ldquo;Server Actions vs. tRPC in 2025: When to Use What\u0026rdquo;\nSubscribe via RSS | Follow on X\n","date":"2025-11-06T00:00:00Z","image":"https://ferdo.us/p/efficient-state-management-in-react-19/cover_hu_27f68e719f73fc0e.jpg","permalink":"https://ferdo.us/p/efficient-state-management-in-react-19/","title":"Efficient State Management in React 19"},{"content":"Welcome to My Programming Journey Hey there, fellow coders and curious minds! I\u0026rsquo;m Ferdous, a software developer from Bangladesh, and this is the launchpad for my new blog. If you\u0026rsquo;ve ever stared at a blank editor, wrestled with a stubborn bug at 2 AM, or felt that rush when your code finally compiles and runs perfectly—then you\u0026rsquo;re in the right place.\nWhy I\u0026rsquo;m Starting This Blog Programming isn\u0026rsquo;t just my job; it\u0026rsquo;s my passion. Over the years, I\u0026rsquo;ve dived into everything from building web apps with JavaScript and React to optimizing backend systems with Python and Node.js. I\u0026rsquo;ve contributed to open-source projects, debugged production crashes under pressure, and learned that every error message is a story waiting to be told.\nBut here\u0026rsquo;s the thing: the best lessons often come from real-world failures and triumphs, not just textbooks. That\u0026rsquo;s what I want to share here—practical insights, code snippets that actually work, and honest takes on the tools and trends shaping our industry.\nWhat You Can Expect This blog will be your go-to resource for:\nTutorials and How-Tos: Step-by-step guides on modern frameworks, algorithms, and best practices. Whether you\u0026rsquo;re a beginner tackling your first \u0026ldquo;Hello World\u0026rdquo; or a seasoned dev optimizing for scale, I\u0026rsquo;ll break it down with clear examples.\nProblem-Solving Deep Dives: Real bugs I\u0026rsquo;ve squashed, performance bottlenecks I\u0026rsquo;ve fixed, and the \u0026ldquo;aha!\u0026rdquo; moments that followed. Expect code in languages like JavaScript, Python, Go, and more.\nTool Reviews and Tips: From VS Code extensions that save hours to deployment strategies on AWS or Vercel—I\u0026rsquo;ll share what works (and what doesn\u0026rsquo;t) in 2025\u0026rsquo;s fast-evolving ecosystem.\nThoughts on the Bigger Picture: AI in coding, remote work hacks, career advice for devs in emerging markets like Bangladesh, and the occasional rant about deprecated APIs.\nLet\u0026rsquo;s Build Something Awesome Together I\u0026rsquo;m kicking things off with a post next week on \u0026ldquo;Efficient State Management in React 19\u0026rdquo; – complete with a live demo repo. Subscribe (or follow me on X at @ferdous) to stay in the loop.\nGot a topic you\u0026rsquo;d love to see? A question about your latest project? Drop a comment below or ping me on X. This blog is as much yours as it is mine.\nHere\u0026rsquo;s to cleaner code, fewer bugs, and endless curiosity. Let\u0026rsquo;s code!\nFerdous\nDhaka, Bangladesh\nNovember 15, 2025\nPhoto by Fotis Fotopoulos on Unsplash\n","date":"2025-11-06T00:00:00Z","image":"https://ferdo.us/p/hello-world/cover_hu_d8697b00f0a04076.jpg","permalink":"https://ferdo.us/p/hello-world/","title":"Hello World"}]